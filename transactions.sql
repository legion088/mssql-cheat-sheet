----T-SQL – это расширение языка SQL, реализованное в Microsoft SQL Server.
----Транзакция – это команда или блок команд (инструкций). Транзакции очень полезны и просто незаменимы в тех случаях, когда необходимо реализовывать бизнес логику в базе данных , которая предполагает многошаговые операции, где каждый шаг логически связан с другими шагами.
----Другими словами, если одна команда или инструкция внутри транзакции завершилась с ошибкой, то все, что было отработано перед ней, также отменяется, даже если предыдущие команды завершились успешно.

---Пример
----Допустим, у Вас есть хранимая процедура, которая осуществляет перевод средств с одного счета на другой, соответственно, как минимум у Вас будет две операции в этой процедуре, снятие средств, и зачисление средств.
----Но в каждой из этих операций может возникнуть ошибка и инструкция не выполнится. А теперь представьте, что первая инструкция снимает деньги, она выполнилась успешно, вторая инструкция зачисляет деньги и в ней возникла ошибка, без транзакции снятые деньги просто потеряются, так как они никуда не будут зачислены.
----Чтобы этого не допустить, все SQL инструкции, которые логически что-то объединяет, в данном случае все операции, связанные с переводом средств, пишут внутри транзакции, и тогда, если наступит подобная ситуация, все изменения будут отменены, т.е. деньги вернутся обратно на счет.

----Команды управления транзакциями в T-SQL:
----BEGIN TRANSACTION   – команда служит для определения начала транзакции.
----COMMIT TRANSACTION  – с помощью данной команды мы сообщаем SQL серверу об успешном завершении транзакции, и о том, что все изменения, которые были выполнены, необходимо сохранить на постоянной основе;
----ROLLBACK TRANSACTION  – служит для отмены всех изменений, которые были внесены в процессе выполнения транзакции, например, в случае ошибки, мы откатываем все назад;
----SAVE TRANSACTION  – данная команда устанавливает промежуточную точку сохранения внутри транзакции, к которой можно откатиться, в случае возникновения необходимости.

--__________________________________________________________________________________________________________________________
--- Пример без ошибки. Сначала мы открываем транзакцию командой BEGIN TRANSACTION 
BEGIN TRANSACTION

   --Инструкция 1
   UPDATE students SET first_name = 'Алёша'
   WHERE students_id = 1;

   --Инструкция 2
   UPDATE students SET first_name = 'Алёша'
   WHERE students_id = 2;

---После этого командой COMMIT TRANSACTION мы сохраняем все внесенные изменения
COMMIT TRANSACTION

--______________________________________________________________________________________________________________________________

SELECT students_id, last_name, first_name FROM students;

--______________________________________________________________________________________________________________________________

--- Пример с ошибкой.  Не тот тип данных. Итог - обновления не выполнятся.
BEGIN TRANSACTION

   --Инструкция 1
   UPDATE students SET date_of_birth = 1993-01-01
   WHERE students_id = 1;

   --Инструкция 2
   UPDATE students SET date_of_birth = 'Алёша'
   WHERE students_id = 2;

---После этого командой COMMIT TRANSACTION мы сохраняем все внесенные изменения
COMMIT TRANSACTION
--______________________________________________________________________________________________________________________________

SELECT students_id, last_name, first_name, date_of_birth FROM students;



----TRY… CATCH. ROLLBACK TRANSACTION. В языке T-SQL существует механизм перехвата и обработки ошибок – конструкция TRY… CATCH. Сначала мы открываем блок для обработки ошибок, затем открываем транзакцию командой BEGIN TRANSACTION, далее пишем наши инструкции, например, те же самые две инструкции UPDATE.
----После этого закрываем блок TRY, открываем блок CATCH, в котором в случае возникновения ошибки мы откатываем все изменения командой ROLLBACK TRANSACTION. Также мы принудительно завершаем нашу инструкцию командой RETURN. Если ошибок нет, то в блок CATCH мы, соответственно, не попадаем и у нас выполнится команда COMMIT TRANSACTION, которая сохранит все изменения.

--______________________________________________________________________________________________________________________________

 BEGIN TRY
   --Начало транзакции
   BEGIN TRANSACTION

    --Инструкция 1
   UPDATE students SET date_of_birth = '1993-01-01'
   WHERE students_id = 1;

   --Инструкция 2
   UPDATE students SET date_of_birth = 'Алёша'
   WHERE students_id = 2;
   END TRY
   BEGIN CATCH
      --В случае непредвиденной ошибки
      --Откат транзакции
      ROLLBACK TRANSACTION

      --Выводим сообщение об ошибке
      SELECT ERROR_NUMBER() AS [Номер ошибки],
             ERROR_MESSAGE() AS [Описание ошибки]

   --Прекращаем выполнение инструкции
   RETURN

   END CATCH

   --Если все хорошо. Сохраняем все изменения
   COMMIT TRANSACTION

   
 --______________________________________________________________________________________________________________________________

-----Уровни изоляции транзакций в T-SQL
----Во время выполнения транзакции все данные, над которыми производятся изменения, блокируются, до завершения транзакции, так как, когда один процесс изменяет данные, другой процесс не может одновременно изменять их. В SQL сервере существует механизм, который блокирует (изолирует) данные во время выполнения транзакции. Блокировки в SQL Server позволяют обеспечивать целостность данных при одновременном изменении несколькими пользователя. SQL Server блокирует объекты в таблице при начале транзакции и снимает блокировку при её завершении.
--У данного механизма есть несколько уровней изоляции, каждый из которых определяет степень блокировки данных.

--READ UNCOMMITTED
--Самый низкий уровень, при котором SQL сервер разрешает так называемое «грязное чтение». иными словами, если транзакция, которая изменяет данные, не завершена, другая транзакция может получить уже измененные данные, хотя они еще не зафиксированы и могут отмениться.

--READ COMMITTED
--Данный уровень по умолчанию используется SQL сервером. Этот уровень уже запрещает грязное чтение, в данном случае все процессы, запросившие данные, которые изменяются в тот же момент в другой транзакции, будут ждать завершения этой транзакции и подтверждения фиксации данных. 

--REPEATABLE READ
--На данном уровне изоляции запрещается изменение данных между двумя операциями чтения в одной транзакции. Здесь происходит запрет на так называемое «неповторяющееся чтение» или «несогласованный анализ». Другими словами, если в одной транзакции есть несколько операций чтения, данные будут блокированы и их нельзя будет изменить в другой транзакции. Таким образом, Вы избежите ситуации, когда вначале транзакции Вы запросили данные, провели их анализ (некое вычисление), в конце транзакции запросили те же самые данные, а они уже отличаются от первоначальных, так как они были изменены другой транзакцией.

--Также уровень REPEATABLE READ, как и остальные, запрещает «Потерянное обновление» – это когда две транзакции сначала считывают одни и те же данные, а затем изменяют их на основе неких вычислений, в результате обе транзакции выполнятся, но данные будут те, которая зафиксировала последняя операция обновления. Это происходит потому, что данные в операциях чтения в начале этих транзакций не были заблокированы.

--SERIALIZABLE
--Данный уровень исключает чтение «фантомных» записей. Фантомные записи – это те записи, которые появились между началом и завершением транзакции. Иными словами, в начале транзакции Вы запросили определенные данные, в конце транзакции Вы запрашиваете их снова с тем же фильтром, но там уже есть и новые данные, которые добавлены другой транзакцией. Более низкие уровни изоляции не блокировали строки, которых еще нет в таблице, данный уровень блокирует все строки, соответствующие фильтру запроса, с которыми будет работать транзакция, как существующие, так и те, что могут быть добавлены.

 --______________________________________________________________________________________________________________________________
--- Посмотрим уровни изоляции: 
SELECT CASE transaction_isolation_level 
    WHEN 0 THEN 'Unspecified' 
    WHEN 1 THEN 'ReadUncommitted' 
    WHEN 2 THEN 'ReadCommitted' 
    WHEN 3 THEN 'Repeatable' 
    WHEN 4 THEN 'Serializable' 
    WHEN 5 THEN 'Snapshot' END AS TRANSACTION_ISOLATION_LEVEL 
FROM sys.dm_exec_sessions 
where session_id = @@SPID

 --______________________________________________________________________________________________________________________________
---Добавление 1 000 000 текстовых записей на русском языке длиной не менее 100 символов UNICODE в таблицу:

--DECLARE @i INT = 1

--WHILE @i <= 1000000
--BEGIN
--  INSERT INTO transactions(Record)
--  VALUES ('Текстовая запись ' + CAST(@i AS NVARCHAR(20)))

--  SET @i = @i + 1
--END


----Использование транзакции для выполнения запроса
 --______________________________________________________________________________________________________________________________
BEGIN TRANSACTION

DECLARE @i INT = 1

WHILE @i <= 10000 
BEGIN
	UPDATE transactions
	SET Record = REPLACE(Record, 'Текстовая запись ' 	+ CAST(@i AS NVARCHAR(20)), 
	                             'Текстовая запись транзакции ' + CAST(@i AS NVARCHAR(20)))
	WHERE Record = 'Текстовая запись ' 	+ CAST(@i AS NVARCHAR(20)) 
	SET @i = @i + 1
END

COMMIT
 --______________________________________________________________________________________________________________________________

---Выполним транзакцию чтения данных. Этот уровень уже запрещает грязное чтение, в данном случае все процессы, запросившие данные, которые изменяются в тот же момент в другой транзакции, будут ждать завершения этой транзакции
BEGIN TRANSACTION
	SELECT * FROM transactions
COMMIT

 --______________________________________________________________________________________________________________________________

----Попробуем установить уровень READ UNCOMMITTED и прочесть.  транзакция может получить уже измененные данные, хотя они еще не зафиксированы и могут отмениться
 --______________________________________________________________________________________________________________________________
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
 --______________________________________________________________________________________________________________________________

BEGIN TRANSACTION
	SELECT * FROM transactions
COMMIT

 --______________________________________________________________________________________________________________________________

---Смотрим какой уровень сейчас
SELECT CASE transaction_isolation_level 
    WHEN 0 THEN 'Unspecified' 
    WHEN 1 THEN 'ReadUncommitted' 
    WHEN 2 THEN 'ReadCommitted' 
    WHEN 3 THEN 'Repeatable' 
    WHEN 4 THEN 'Serializable' 
    WHEN 5 THEN 'Snapshot' END AS TRANSACTION_ISOLATION_LEVEL 
FROM sys.dm_exec_sessions 
where session_id = @@SPID
